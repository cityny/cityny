name: Repo List Generator

on:
  schedule:
    - cron: '0 0 * * *'  # EjecuciÃ³n diaria
  workflow_dispatch:      # Permite ejecuciÃ³n manual

jobs:
  repo-list:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      # Genera la imagen de estadÃ­sticas localmente
      - name: Generate Stats Images
        uses: lowlighter/metrics@latest
        with:
          token: ${{ secrets.REPO_TOKEN }}
          user: cityny
          template: classic
          base: header, activity, community, repositories, metadata
          config_timezone: America/Caracas
          filename: generated/stats.svg 

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: Get Repo List Data (API Directa)
        id: repo_data
        run: |
          REPO_LIST=$(curl -s -H "Authorization: token ${{ secrets.REPO_TOKEN }}" \
            "https://api.github.com/users/cityny/repos?per_page=100&type=all")
          STARRED_REPOS=$(curl -s -H "Authorization: token ${{ secrets.REPO_TOKEN }}" \
            "https://api.github.com/users/cityny/starred?per_page=100")
          OWN_REPOS=$(echo "$REPO_LIST" | jq -r '.[] | select(.fork == false) | .full_name' | tr '\n' ',')
          FORK_REPOS=$(echo "$REPO_LIST" | jq -r '.[] | select(.fork == true) | .full_name' | tr '\n' ',')
          STARRED_REPOS_LIST=$(echo "$STARRED_REPOS" | jq -r '.[].full_name' | tr '\n' ',')
          echo "ownRepos=$OWN_REPOS" >> $GITHUB_OUTPUT
          echo "forkRepos=$FORK_REPOS" >> $GITHUB_OUTPUT
          echo "starredRepos=$STARRED_REPOS_LIST" >> $GITHUB_OUTPUT
        shell: bash

      - name: Write to README using Python
        shell: python
        run: |
                import os
                # Recuperamos las listas de los pasos anteriores
                own_repos = "${{ steps.repo_data.outputs.ownRepos }}"
                fork_repos = "${{ steps.repo_data.outputs.forkRepos }}"
                starred_repos = "${{ steps.repo_data.outputs.starredRepos }}"
                
                with open("README.md", "r", encoding="utf-8") as f:
                    content = f.read()
      
                def update_section(content, start_tag, end_tag, repo_list):
                    # Verificamos que los tags existan en el README antes de operar
                    if start_tag in content and end_tag in content:
                        pre = content.split(start_tag)[0]
                        post = content.split(end_tag)[1]
                        repo_names = sorted(repo_list.split(',')) if repo_list else []
                        markdown_list = "\n".join(
                            f"- [{repo.split('/')[1]}](https://github.com/{repo})"
                            for repo in repo_names if repo
                        )
                        return f"{pre}{start_tag}\n{markdown_list.strip()}\n{end_tag}{post}"
                    return content
      
                # DEFINICIÃ“N DIRECTA (No las dejes vacÃ­as)
                content = update_section(content, "", "", own_repos)
                content = update_section(content, "", "", fork_repos)
                content = update_section(content, "", "", starred_repos)
      
                with open("README.md", "w", encoding="utf-8") as f:
                    f.write(content)
                print("README actualizado con Ã©xito.")

      - name: Commit and Push Changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git pull origin main
          git add README.md generated/
          git commit -m "ðŸ¤– Stats y Repos actualizados sin errores" || echo "Nada que actualizar"
          git push origin main
